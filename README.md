# Лабораторная работа 14: CompletableFuture и асинхронное программирование

### **Студент:** [Сержан К.С.]
### **Группа:** [КИ 23-03]
### **Дата:** [02.12.2025]

---

## Цель работы

Целью лабораторной работы является изучение и применение **CompletableFuture** для создания высокопроизводительного, асинхронного конвейера обработки заказов, демонстрируя создание, связывание, комбинирование, управление потоками и обработку ошибок в цепочках асинхронных операций.

## Реализация

Был реализован асинхронный конвейер, созданный в классе `OrderProcessingService`, который обрабатывает каждый заказ в 5 последовательных, но асинхронных этапов.

### Основные классы

* `Order`, `Product`, `OrderResult`: Модели данных
* `OrderProcessingService`: Содержит асинхронные методы-этапы и главный конвейер processOrder
* `OrderProcessor`: Точка входа, создает тестовые данные и запускает параллельную обработку

### Асинхронный конвейер
Методы CompletableFuture:

* **`supplyAsync()` / `runAsync()`** — запускают длительные I/O-операции (проверка склада, обработка платежа) в выделенном пуле потоков, обеспечивая асинхронное выполнение.
* **`thenCompose()`** — связывает **зависимые** асинхронные шаги (например, расчет цены после проверки наличия), обеспечивая строгую последовательность в цепочке.
* **`thenCombine()`** — используется для **объединения** результатов двух фьючеров, которые выполнялись независимо или параллельно (например, цены и резервирования).
* **`allOf()`** — в методе `processMultipleOrders` ожидает завершения **ВСЕХ** запущенных заказов, позволяя собрать итоговый результат.
* **`orTimeout()`** — устанавливает **таймаут** на всю цепочку, прерывая ее с исключением при превышении заданного времени.
* **`handle()`** — ключевой механизм **обработки ошибок**, который перехватывает исключения в любой точке цепочки и преобразует сбой в корректный объект-результат (`OrderResult` с флагом ошибки)
* **`whenComplete()`** — выполняет **финальное действие** (логирование времени и статуса) после завершения фьючера, независимо от того, был ли он успешен или завершился ошибкой


### Анализ Производительности

Тестовые условия включали 7 заказов, каждый из которых содержал совокупную симулированную задержку примерно 5.3 секунды

#### Сравнение Времени Выполнения

1.  **Последовательный режим (блокирующий)**: При выполнении заказов один за другим, общее время обработки составило бы 37.1 секунды
2.  **Параллельный режим (асинхронный)**: Благодаря использованию `CompletableFuture` и `ExecutorService`, I/O-операции всех 7 заказов выполняются одновременно. Общее время обработки ограничивается самым долгим шагом в конвейере, плюс накладные расходы. Составляет 5.5 секунды

#### Вывод

Использование асинхронности позволило добиться ускорения обработки примерно в 6.7 раз , используя пул потоков в 10 штук. Этот результат доказывает, что `CompletableFuture` очень важен для I/O-bound систем. Он позволяет не блокировать ресурсы процессора во время ожидания и повышает общую пропускную способность системы.

1.  **CompletableFuture** является эффективным инструментом для реализации асинхронного, неблокирующего кода, особенно для I/O-bound задач
2.  Правильное связывание операций через `thenCompose` и `thenCombine` позволяет создать надежный и структурированный конвейер
3.  Обработки ошибок, такие как `handle` и `orTimeout`, обязательны в асинхронном коде, чтобы гарантировать, что сбой одного элемента не приводит к отказу всей системы
4.  Использование `ExecutorService` предотвращает истощение пула `ForkJoinPool` и обеспечивает предсказуемость производительности

---

## Контрольные вопросы

### 1. В чем разница между `thenApply` и `thenCompose`?
* **`thenApply`**: Принимает `Function` (лямбда-выражение), которое возвращает значение. Используется для синхронного преобразования результата. *Результат:* `CompletableFuture<T>`
* **`thenCompose`**: Принимает `Function`, которое возвращает новый CompletableFuture. Используется для создания зависимых асинхронных цепочек, где результат предыдущего фьючера передается в следующий асинхронный шаг. *Результат:* `CompletableFuture<T>` (сглаживает вложенный фьючер).

### 2. Когда следует использовать `Async` версии методов?
* Для тяжелых, длительных CPU-bound операций (чтобы не блокировать основной поток и не занимать I/O-потоки)
* Для всех I/O-bound операций (работа с сетью, БД), используя при этом кастомный `ExecutorService` для эффективного управления I/O-задержками

### 3. Как правильно обработать ошибку в середине цепочки `CompletableFuture`?
Метод `handle(result, ex)` является универсальным в этом случае. Он вызывается независимо от того, завершился ли предыдущий этап успехом или исключением. Внутри `handle` можно проверить, что `ex != null`, обработать ошибку и вернуть нормальный результат, что позволит всей цепочке завершиться без сбоя.

### 4. В чем разница между `allOf` и `anyOf`?
* **`allOf`**: Возвращает `CompletableFuture<Void>`, который завершается только тогда, когда все переданные ему фьючеры завершены. Используется для параллельного выполнения задач с ожиданием общего завершения.
* **`anyOf`**: Возвращает `CompletableFuture<Object>`, который завершается, как только любой из переданных ему фьючеров завершится. Используется для сценариев "кто быстрее".

### 5. Зачем нужен кастомный `ExecutorService` для `CompletableFuture`?
* **Для разделения задач:** Кастомный пул позволяет разделить CPU-bound задачи и I/O-bound задачи, предотвращая их взаимную блокировку
* **Для избежания блокировки:** I/O-операции могут блокировать потоки на долгое время. Если они будут использовать commonPool(), это приведет к его истощению, что замедлит другие CPU-задачи
* **Для управления ресурсами:** Он позволяет точно контролировать количество потоков, выделяемых для конкретной части системы

### 6. Что произойдет, если не вызвать `shutdown()` на `ExecutorService`?
Если не вызвать `shutdown()` на кастомном ExecutorService, пул потоков останется активным, и программа не завершится. Потоки будут продолжать работать в фоновом режиме, ожидая новых задач, не давая JVM завершить работу

### 7. В чем разница между `exceptionally` и `handle`?
* **`exceptionally(fn)`**: Вызывается только при исключении. Позволяет вернуть нормальное значение и продолжить цепочку, как если бы ошибки не было. Не видит результат в случае успеха
* **`handle(fn)`**: Вызывается всегда, независимо от результата. Принимает как результат, так и исключение. Это позволяет провести логику ветвления 

### 8. Как установить таймаут для асинхронной операции?
Для установки таймаута используется метод **`orTimeout(long timeout, TimeUnit unit)`**

```
CompletableFuture.supplyAsync(() -> longRunningTask())
    .orTimeout(10, TimeUnit.SECONDS); // Бросит TimeoutException
