# Лабораторная работа 14: CompletableFuture и асинхронное программирование

### **Студент:** [Сержан К.С.]
### **Группа:** [КИ 23-03]
### **Дата:** [02.12.2025]

---

## Цель работы

Целью лабораторной работы является изучение и применение **CompletableFuture** для создания высокопроизводительного, асинхронного конвейера обработки заказов, демонстрируя создание, связывание, комбинирование, управление потоками и обработку ошибок в цепочках асинхронных операций.

## Реализация

Был реализован асинхронный конвейер, созданный в классе `OrderProcessingService`, который обрабатывает каждый заказ в 5 последовательных, но асинхронных этапов.

### Основные классы

* `Order`, `Product`, `OrderResult`: Модели данных
* `OrderProcessingService`: Содержит асинхронные методы-этапы и главный конвейер processOrder
* `OrderProcessor`: Точка входа, создает тестовые данные и запускает параллельную обработку

### Асинхронный конвейер
Методы CompletableFuture:

* **`supplyAsync()` / `runAsync()`** — запускают длительные I/O-операции (проверка склада, обработка платежа) в выделенном пуле потоков, обеспечивая асинхронное выполнение.
* **`thenCompose()`** — связывает **зависимые** асинхронные шаги (например, расчет цены после проверки наличия), обеспечивая строгую последовательность в цепочке.
* **`thenCombine()`** — используется для **объединения** результатов двух фьючеров, которые выполнялись независимо или параллельно (например, цены и резервирования).
* **`allOf()`** — в методе `processMultipleOrders` ожидает завершения **ВСЕХ** запущенных заказов, позволяя собрать итоговый результат.
* **`orTimeout()`** — устанавливает **таймаут** на всю цепочку, прерывая ее с исключением при превышении заданного времени.
* **`handle()`** — ключевой механизм **обработки ошибок**, который перехватывает исключения в любой точке цепочки и преобразует сбой в корректный объект-результат (`OrderResult` с флагом ошибки)
* **`whenComplete()`** — выполняет **финальное действие** (логирование времени и статуса) после завершения фьючера, независимо от того, был ли он успешен или завершился ошибкой

### Вывод программы

```
╔══════════════════════════════════════════════╗
║ ПАРАЛЛЕЛЬНАЯ ОБРАБОТКА ЗАКАЗОВ ║
╚══════════════════════════════════════════════╝

=== Начало обработки заказа ORD001 ===
[ORD001] Проверка наличия товара...

=== Начало обработки заказа ORD002 ===

=== Начало обработки заказа ORD003 ===
[ORD002] Проверка наличия товара...
[ORD003] Проверка наличия товара...

=== Начало обработки заказа ORD004 ===

=== Начало обработки заказа ORD005 ===
[ORD004] Проверка наличия товара...

=== Начало обработки заказа ORD006 ===
[ORD005] Проверка наличия товара...

=== Начало обработки заказа ORD007 ===
[ORD006] Проверка наличия товара...
[ORD007] Проверка наличия товара...
[ORD006] ✗ Ошибка обработки: Ошибка обработки: Товар PROD999 не найден (за 1006 мс)
[ORD007] ✗ Ошибка обработки: Ошибка обработки: Недостаточно товара на складе. Требуется: 100, в наличии: 10 (за 1006 мс)
[ORD003] Товар найден: Клавиатура (8500,00₸, в наличии: 30)
[ORD005] Товар найден: Наушники (12000,00₸, в наличии: 25)
[ORD002] Товар найден: Мышь (3500,00₸, в наличии: 50)
[ORD001] Товар найден: Ноутбук (150000,00₸, в наличии: 10)
[ORD004] Товар найден: Монитор (85000,00₸, в наличии: 15)
[ORD004] Расчет стоимости...
[ORD001] Расчет стоимости...
[ORD003] Расчет стоимости...
[ORD005] Расчет стоимости...
[ORD002] Расчет стоимости...
[ORD001] Стоимость с учетом налога: 336000,00T
[ORD003] Стоимость с учетом налога: 47600,00T
[ORD004] Стоимость с учетом налога: 95200,00T
[ORD002] Стоимость с учетом налога: 35280,00T
[ORD005] Стоимость с учетом налога: 40320,00T
[ORD003] Обработка платежа на сумму 47600,00₸...
[ORD002] Обработка платежа на сумму 35280,00₸...
[ORD005] Обработка платежа на сумму 40320,00₸...
[ORD004] Обработка платежа на сумму 95200,00₸...
[ORD001] Обработка платежа на сумму 336000,00₸...
[ORD003] Платеж успешен
[ORD002] ✗ Ошибка обработки: Ошибка обработки: Payment failed (симуляция ошибки) (за 3526 мс)
[ORD004] Платеж успешен
[ORD001] Платеж успешен
[ORD005] Платеж успешен
[ORD001] Резервирование товара Ноутбук...
[ORD005] Резервирование товара Наушники...
[ORD004] Резервирование товара Монитор...
[ORD003] Резервирование товара Клавиатура...
[ORD004] Товар зарезервирован (новый запас: 14)
[ORD003] Товар зарезервирован (новый запас: 25)
[ORD005] Товар зарезервирован (новый запас: 22)
[ORD001] Товар зарезервирован (новый запас: 8)
[ORD003] Отправка уведомления на customer3@example.com...
[ORD004] Отправка уведомления на customer4@example.com...
[ORD005] Отправка уведомления на customer5@example.com...
[ORD001] Отправка уведомления на customer1@example.com...
[ORD003] Уведомление отправлено: Заказ успешно оформлен на сумму 47600,00T!
[ORD004] Уведомление отправлено: Заказ успешно оформлен на сумму 95200,00T!
[ORD005] Уведомление отправлено: Заказ успешно оформлен на сумму 40320,00T!
[ORD001] Уведомление отправлено: Заказ успешно оформлен на сумму 336000,00T!
[ORD003] ✓ Заказ успешно обработан за 5334 мс
[ORD004] ✓ Заказ успешно обработан за 5334 мс
[ORD005] ✓ Заказ успешно обработан за 5333 мс
[ORD001] ✓ Заказ успешно обработан за 5343 мс

╔══════════════════════════════════════════════╗
║ ИТОГОВЫЕ РЕЗУЛЬТАТЫ ║
╚══════════════════════════════════════════════╝

Успешные заказы:
 ✓ ORD001 - 336000,00T - Заказ успешно обработан
 ✓ ORD003 - 47600,00T - Заказ успешно обработан
 ✓ ORD004 - 95200,00T - Заказ успешно обработан
 ✓ ORD005 - 40320,00T - Заказ успешно обработан

Неуспешные заказы:
 ✗ ORD002 - Payment failed (симуляция ошибки)
 ✗ ORD006 - Товар PROD999 не найден
 ✗ ORD007 - Недостаточно товара на складе. Требуется: 100, в наличии: 10
═══════════════════════════════════════════════

СТАТИСТИКА:
 Всего заказов: 7
 Успешных: 4 (57,1%)
 Неуспешных: 3 (42,9%)
 Общая сумма: 519120,00T
 Общее время обработки: 5349 мс
═══════════════════════════════════════════════
```

### Анализ Производительности

Тестовые условия включали 7 заказов, каждый из которых содержал совокупную симулированную задержку примерно 5.3 секунды

#### Сравнение Времени Выполнения

1.  **Последовательный режим (блокирующий)**: При выполнении заказов один за другим, общее время обработки составило бы 37.1 секунды
2.  **Параллельный режим (асинхронный)**: Благодаря использованию `CompletableFuture` и `ExecutorService`, I/O-операции всех 7 заказов выполняются одновременно. Общее время обработки ограничивается самым долгим шагом в конвейере, плюс накладные расходы. Составляет 5.5 секунды

#### Вывод

Использование асинхронности позволило добиться ускорения обработки примерно в 6.7 раз , используя пул потоков в 10 штук. Этот результат доказывает, что `CompletableFuture` очень важен для I/O-bound систем. Он позволяет не блокировать ресурсы процессора во время ожидания и повышает общую пропускную способность системы.

1.  **CompletableFuture** является эффективным инструментом для реализации асинхронного, неблокирующего кода, особенно для I/O-bound задач
2.  Правильное связывание операций через `thenCompose` и `thenCombine` позволяет создать надежный и структурированный конвейер
3.  Обработки ошибок, такие как `handle` и `orTimeout`, обязательны в асинхронном коде, чтобы гарантировать, что сбой одного элемента не приводит к отказу всей системы
4.  Использование `ExecutorService` предотвращает истощение пула `ForkJoinPool` и обеспечивает предсказуемость производительности

---

## Контрольные вопросы

### 1. В чем разница между `thenApply` и `thenCompose`?
* **`thenApply`**: Принимает `Function` (лямбда-выражение), которое возвращает значение. Используется для синхронного преобразования результата. *Результат:* `CompletableFuture<T>`
* **`thenCompose`**: Принимает `Function`, которое возвращает новый CompletableFuture. Используется для создания зависимых асинхронных цепочек, где результат предыдущего фьючера передается в следующий асинхронный шаг. *Результат:* `CompletableFuture<T>` (сглаживает вложенный фьючер).

### 2. Когда следует использовать `Async` версии методов?
* Для тяжелых, длительных CPU-bound операций (чтобы не блокировать основной поток и не занимать I/O-потоки)
* Для всех I/O-bound операций (работа с сетью, БД), используя при этом кастомный `ExecutorService` для эффективного управления I/O-задержками

### 3. Как правильно обработать ошибку в середине цепочки `CompletableFuture`?
Метод `handle(result, ex)` является универсальным в этом случае. Он вызывается независимо от того, завершился ли предыдущий этап успехом или исключением. Внутри `handle` можно проверить, что `ex != null`, обработать ошибку и вернуть нормальный результат, что позволит всей цепочке завершиться без сбоя.

### 4. В чем разница между `allOf` и `anyOf`?
* **`allOf`**: Возвращает `CompletableFuture<Void>`, который завершается только тогда, когда все переданные ему фьючеры завершены. Используется для параллельного выполнения задач с ожиданием общего завершения.
* **`anyOf`**: Возвращает `CompletableFuture<Object>`, который завершается, как только любой из переданных ему фьючеров завершится. Используется для сценариев "кто быстрее".

### 5. Зачем нужен кастомный `ExecutorService` для `CompletableFuture`?
* **Для разделения задач:** Кастомный пул позволяет разделить CPU-bound задачи и I/O-bound задачи, предотвращая их взаимную блокировку
* **Для избежания блокировки:** I/O-операции могут блокировать потоки на долгое время. Если они будут использовать commonPool(), это приведет к его истощению, что замедлит другие CPU-задачи
* **Для управления ресурсами:** Он позволяет точно контролировать количество потоков, выделяемых для конкретной части системы

### 6. Что произойдет, если не вызвать `shutdown()` на `ExecutorService`?
Если не вызвать `shutdown()` на кастомном ExecutorService, пул потоков останется активным, и программа не завершится. Потоки будут продолжать работать в фоновом режиме, ожидая новых задач, не давая JVM завершить работу

### 7. В чем разница между `exceptionally` и `handle`?
* **`exceptionally(fn)`**: Вызывается только при исключении. Позволяет вернуть нормальное значение и продолжить цепочку, как если бы ошибки не было. Не видит результат в случае успеха
* **`handle(fn)`**: Вызывается всегда, независимо от результата. Принимает как результат, так и исключение. Это позволяет провести логику ветвления 

### 8. Как установить таймаут для асинхронной операции?
Для установки таймаута используется метод **`orTimeout(long timeout, TimeUnit unit)`**

```
CompletableFuture.supplyAsync(() -> longRunningTask())
    .orTimeout(10, TimeUnit.SECONDS); // Бросит TimeoutException
